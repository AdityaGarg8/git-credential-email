#!/usr/bin/python3
#
# Copyright 2012 Google Inc.
# Copyright 2025 Aditya Garg
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#	http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import sys

if "--help" in sys.argv:
	print("""
Usage: git-credential-gmail [OPTIONS]

Options:
  --help               * Show this help message and exit.
  --authenticate       * Authenticate with Gmail using OAuth2.
  --verbose            * Enable verbose logging during authentication.

Description:
  This script allows you to authenticate with Gmail using OAuth2 and
  retrieve access tokens for use with IMAP, POP, and SMTP protocols.

Examples:
  Authenticate using the browser-based flow:
    git-credential-gmail --authenticate
""")
	sys.exit(0)

import http.server
import json
import keyring
import os
import random
import threading
import urllib.parse
import urllib.request

# https://github.com/mozilla/releases-comm-central/blob/master/mailnews/base/src/OAuth2Providers.sys.mjs
ClientId_Thunderbird = "406964657835-aq8lmia8j95dhl1a2bvharmfk3t1hgqj.apps.googleusercontent.com"
ClientSecret_Thunderbird = "kSmqreRr0qwBWJgbf5Y-PjSU"

# https://gitlab.gnome.org/GNOME/evolution-data-server/-/commit/7554d3b95124486ac98d9a5052e069e46242a216
ClientId_Evolution = "590402290962-2i0b7rqma8b9nmtfrcp7fa06g6cf7g74.apps.googleusercontent.com"
ClientSecret_Evolution = "mtfUe5W8Aal9DcgVipOY1T9G"

# https://gitlab.gnome.org/GNOME/gnome-online-accounts/-/blob/master/meson_options.txt
ClientId_Gnome = "44438659992-7kgjeitenc16ssihbtdjbgguch7ju55s.apps.googleusercontent.com"
ClientSecret_Gnome = "-gMLuQyDiI0XrQS_vx_mhuYF"

# ClientId and ClientSecret to be used

ClientId = ClientId_Thunderbird
ClientSecret = ClientSecret_Thunderbird

Scopes = "https://mail.google.com/"
ServiceName = "git-credential-gmail"

def save_refresh_token(refresh_token):
	keyring.set_password(ServiceName, "refresh_token", refresh_token)

def load_refresh_token():
	return keyring.get_password(ServiceName, "refresh_token")

def AccountsUrl(command):
	return '%s/%s' % ('https://accounts.google.com', command)

def UrlEscape(text):
	return urllib.parse.quote(text, safe='~-._')

def FormatUrlParams(params):
	param_fragments = []
	for param in sorted(params.items(), key=lambda x: x[0]):
		param_fragments.append('%s=%s' % (param[0], UrlEscape(param[1])))
	return '&'.join(param_fragments)

def GeneratePermissionUrl(redirect_uri):
	params = {}
	params['client_id'] = ClientId
	params['redirect_uri'] = redirect_uri
	params['scope'] = Scopes
	params['response_type'] = 'code'
	params['access_type'] = 'offline'
	params['prompt'] = 'consent'
	return '%s?%s' % (AccountsUrl('o/oauth2/auth'), FormatUrlParams(params))

def AuthorizeTokens(authorization_code):
	params = {}
	params['client_id'] = ClientId
	params['client_secret'] = ClientSecret
	params['code'] = authorization_code
	params['redirect_uri'] = redirect_uri
	params['grant_type'] = 'authorization_code'
	request_url = AccountsUrl('o/oauth2/token')

	try:
		response = urllib.request.urlopen(request_url, urllib.parse.urlencode(params).encode('utf-8')).read()
		return json.loads(response)
	except urllib.error.HTTPError as e:
		print(f"HTTP Error {e.code}: {e.reason}")
		print("Response Body:", e.read().decode())
		sys.exit("\nFailed to get refresh token due to an HTTP error.")
	except Exception as e:
		print(f"Unexpected error: {e}")
		sys.exit("\nFailed to get refresh token due to an unexpected error.")

def RefreshToken(refresh_token):
	params = {}
	params['client_id'] = ClientId
	params['client_secret'] = ClientSecret
	params['refresh_token'] = refresh_token
	params['grant_type'] = 'refresh_token'
	request_url = AccountsUrl('o/oauth2/token')

	try:
		response = urllib.request.urlopen(request_url, urllib.parse.urlencode(params).encode('utf-8')).read()
		return json.loads(response)
	except urllib.error.HTTPError as e:
		print(f"HTTP Error {e.code}: {e.reason}")
		print("Response Body:", e.read().decode())
		sys.exit("\nFailed to get access token due to an HTTP error.")
	except Exception as e:
		print(f"Unexpected error: {e}")
		sys.exit("\nFailed to get access token due to an unexpected error.")

if "--authenticate" in sys.argv:

	from PyQt6.QtWidgets import QApplication, QMainWindow
	from PyQt6.QtWebEngineWidgets import QWebEngineView
	from PyQt6.QtWebEngineCore import QWebEnginePage
	from PyQt6.QtCore import QUrl, QLoggingCategory

	random_port = random.randint(1024, 65535)
	redirect_uri = f"http://localhost:{random_port}/"
	url = GeneratePermissionUrl(redirect_uri)

	class Handler(http.server.BaseHTTPRequestHandler):
		def log_message(self, format, *args):
			# Override to prevent logging to console
			pass
		def do_GET(self):
			parsed_url = urllib.parse.urlparse(self.path)
			parsed_query = urllib.parse.parse_qs(parsed_url.query)
			global code
			code = parsed_query.get('code', [''])[0]
			self.send_response(200)
			self.end_headers()

			global httpd
			threading.Thread(target=lambda: httpd.shutdown()).start()

	code = ''

	server_address = ('', random_port)
	httpd = http.server.HTTPServer(server_address, Handler)

	threading.Thread(target=httpd.serve_forever, daemon=True).start()

	if "--verbose" in sys.argv:
		loglevel = 0
	else:
		loglevel = 3
		QLoggingCategory("qt.webenginecontext").setFilterRules("*.info=false") # Suppress info logs

	os.environ["QTWEBENGINE_CHROMIUM_FLAGS"] = f"--enable-logging --log-level={loglevel}"

	class QuietWebEnginePage(QWebEnginePage):
		#js messages spam the console for no reason
		def javaScriptConsoleMessage(self, level, message, lineNumber, sourceID):
			return

	print("Opening a browser window for authentication...\n")

	class BrowserWindow(QMainWindow):

		def handle_url_change(self, url):
			if "code=" in url.toString():
				self.close()

		def __init__(self):
			super().__init__()
			self.setWindowTitle("OAuth2 Login")
			self.resize(800, 600)
			self.browser = QWebEngineView()
			if not "--verbose" in sys.argv:
				self.browser.setPage(QuietWebEnginePage(self.browser))
			self.setCentralWidget(self.browser)
			self.browser.load(QUrl(url))
			self.browser.urlChanged.connect(self.handle_url_change)
			self.show()

	webapp = QApplication(sys.argv)
	window = BrowserWindow()
	webapp.exec()

	token = AuthorizeTokens(code)

	if 'error' in token:
		print(token)
		sys.exit("\nFailed to get refresh token")

	print('Saved refresh token to keyring')
	save_refresh_token(token['refresh_token'])

else:
	old_refresh_token = load_refresh_token()

	if old_refresh_token is None:
		sys.exit("No refresh token found.\nPlease authenticate first by running `git credential-gmail --authenticate`")

	token = RefreshToken(old_refresh_token)

	if 'error' in token:
		print(token)
		sys.exit("\nFailed to get access token")

	print(f"password={token['access_token']}")