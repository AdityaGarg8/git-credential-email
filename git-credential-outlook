#!/usr/bin/env python3

from msal import ConfidentialClientApplication, PublicClientApplication, SerializableTokenCache
from tempfile import NamedTemporaryFile
import http.server
import os
import sys
import threading
import urllib.parse
import webbrowser
import random
import keyring
import ssl

ClientId = "9e5f94bc-e8a4-4e73-b8be-63364c29d753"
Scopes = ['https://outlook.office.com/IMAP.AccessAsUser.All','https://outlook.office.com/SMTP.Send']
ServiceName = "git-credential-outlook"

def save_refresh_token(refresh_token):
    keyring.set_password(ServiceName, "refresh_token", refresh_token)

def load_refresh_token():
    return keyring.get_password(ServiceName, "refresh_token")

# We use the cache to extract the refresh token
cache = SerializableTokenCache()

if not "--authenticate" in sys.argv:
    app = ConfidentialClientApplication(ClientId, token_cache=cache)

    old_refresh_token = load_refresh_token()

    if old_refresh_token is None:
        sys.exit("No refresh token found. Please authenticate first.")

    token = app.acquire_token_by_refresh_token(old_refresh_token,Scopes)

    if 'error' in token:
        print(token)
        sys.exit("Failed to get access token")

    print(f"password={token['access_token']}")
    sys.exit(0)

SERVER_CERT = """-----BEGIN CERTIFICATE-----
MIIDazCCAlOgAwIBAgIUeMsQRY4hKFQ1Wiz6vynTfF3q8o8wDQYJKoZIhvcNAQEL
BQAwRTELMAkGA1UEBhMCQVUxEzARBgNVBAgMClNvbWUtU3RhdGUxITAfBgNVBAoM
GEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDAeFw0yMzAyMTUxNTIyMzJaFw0yMzAz
MTcxNTIyMzJaMEUxCzAJBgNVBAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEw
HwYDVQQKDBhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGQwggEiMA0GCSqGSIb3DQEB
AQUAA4IBDwAwggEKAoIBAQCqz+R0JgNYkRYyRMyjQkEpliIu8Vw6c27PPfQjYyK4
UqjkA1iShlZnQJ8w4Yo+muOi8jWk6QrZc2eRhImV6CLKATQ9kK55r6dwR169oEpW
c82skCg5eUlOrNkuyddRuuW8+DqSlCEjnnDMJw3FnQEfCv0KI/ogn2qzHU6cdilE
herkAmtnlNMa6mUjOsqyD0919ZtoahA2SqPZz2eQ3bNCjfsIP/o5uHTUrLppETDe
dTEk4UtaCTptVCDJXJmY0ajzNor1KUFgeOGuZqbPyDUJyF6AKrUN1ijudvJd4SkS
b2zi82WtZNuIA34HOUet710cmOAttu75PP0gSxq7o8nxAgMBAAGjUzBRMB0GA1Ud
DgQWBBTCvuI+KG/WD/3rk+hS2BJ87wuYZjAfBgNVHSMEGDAWgBTCvuI+KG/WD/3r
k+hS2BJ87wuYZjAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3DQEBCwUAA4IBAQB/
gMUIUbTQWhK4e391Nlp7bsI4u1AiLMuIRrZxY9Ukh0mvDV46CtRw1GFpa8rWnos6
Ux+gljX4JcWxFWBVk3fqh2bB6NiL+KGORag0ecl9HnzDFAXL+/m4pQaKbarADdod
TEU9aVCGQB1FKpqUNNZyX5h95EZ28SebGDpTaeMZLgM1CibCZz5+j61EPiw+Lsli
dI4yJ55lrhjqphUQXkvunbqXfDakNA+KqAGErcGcq/mtFJx1vmJ3W6g1tmaHsPSP
IbD1z0+s0KmSQzBO1FKps6bQvEfO2m7ryBT3AfZUjQESLr5rhrxf63BOFDVTOxBK
Sf+xTMt4at+inf7cslft
-----END CERTIFICATE-----
"""

SERVER_KEY = """-----BEGIN PRIVATE KEY-----
MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCqz+R0JgNYkRYy
RMyjQkEpliIu8Vw6c27PPfQjYyK4UqjkA1iShlZnQJ8w4Yo+muOi8jWk6QrZc2eR
hImV6CLKATQ9kK55r6dwR169oEpWc82skCg5eUlOrNkuyddRuuW8+DqSlCEjnnDM
Jw3FnQEfCv0KI/ogn2qzHU6cdilEherkAmtnlNMa6mUjOsqyD0919ZtoahA2SqPZ
z2eQ3bNCjfsIP/o5uHTUrLppETDedTEk4UtaCTptVCDJXJmY0ajzNor1KUFgeOGu
ZqbPyDUJyF6AKrUN1ijudvJd4SkSb2zi82WtZNuIA34HOUet710cmOAttu75PP0g
Sxq7o8nxAgMBAAECggEAJjMtC76uk+GKnb5eJ4q7KPI+/dGThyzmlKltznYuvxsZ
UzjeV5J8g0Xj9BoUgTDBhOD3F0TY3M2e1V/XJzPNh/Ch/ry7EFK0tvr3GKBez5vB
XPy2SjgyKUqlnX2dTlVmaI75BmvjR2R5JGb9gPq+U/NwqJJoL2CHi7wbpwkT7JNJ
+XIxr1Rg/vYoCqFOuhqtKLo9GKwuylWJpWvONdY6Kvuhzqip5Ri28D0StnS7XIEW
LNbS4X1+IrVaqky1WPl6EWMAOUeDzdF/MvsgGh+Xh9jnvM4UXgyjJjObaQX/RZlx
QyxJw0xlZQXo9Yf8hZ0qH2Kzz1c1YfNYLssK8bL6+wKBgQC1O1uVSu2VE/kBex12
QtbX8epGEwiJf/fuQL1bKUEwHMHDu7h5rY02z7IqsJ9aBpL4tHOEVOYPEQxrLwEe
lpgTomHScAJeyswsjGVwcwpx0zrTmIRDA80eAYTGQMkwvLpQuPNrigj81iJAYy/i
I0ajrlLABoTl4t+j3MmJsHZTAwKBgQDxSA7kRKsUSxhbejBK2MgvxfBip0S7q7lM
0y7SjX0o2aEPQGYzdnBAnTNPuN+jRxGNTV1R6wtebfBnjywSzKhkFp9DHPWKVB32
BZbtI0FPWV+w71I8WC5ZFTp0w4+p85W1F2Er4bLt1v/5QoV2G2SrjXjxAEnEzrQn
1uLDrN4i+wKBgDToCyheI1Vt6zdfdY5cnNOVr8qdK9TYIszO4XiHZpxhCL/XQVdk
LuFdaKnFvf9OBAHOzBpJno+vbmyr4CvJ0sOIl/4S7N43XbtzkPlu3BG2lGnJEHNv
3KVx1Az8RL+RmOKP25/9P/pvmLgrPINLwQdvkIC2Zn2l6ZuwjLVBaol5AoGBANVW
jGxDVy1jVM8Vk/uqAB9Vmj3wfjKeHQKTu9PJ7P+gpesRWwxnzcsj9AmqgnshTKCu
5jOXav78oFNA4YxhzwZohjtWMLk1tSQiPxfAU2/wq06L3R+kLJ7xyTUS8UUpLpbn
bDDbqFTqBH0F13HduL6DIYueYJuW1O5g7zJq+CLfAoGALokjslUQPDxS+BRFK/qI
HmcaDX6eJPYQL/s0gXYn3xegaAzwRmV9cZ59JmVQAIeiFJ9UVQLQsVm+l3PF5O5z
QnoyNXeb+hM1rq5Wvs71nfVHRlwg0SMO417chqx/Me6Zgyn69xGmMuV7vWUVsvVn
/Xn1PzN8X7B+0UGLlkRmgfo=
-----END PRIVATE KEY-----
"""

choice = ''
if not "--localhost" in sys.argv and not "--device" in sys.argv:
    print("Choose an authentication method:")
    print("1. Open your browser and login.")
    print("2. Paste a device code manually on a webpage.")
    choice = input("Enter 1 or 2: ").strip()

if choice == "1" or "--localhost" in sys.argv:
    # Use ConfidentialClientApplication for authorization code flow
    app = ConfidentialClientApplication(ClientId, token_cache=cache)

    random_port = random.randint(1024, 65535)
    redirect_uri = f"https://localhost:{random_port}/"
    url = app.get_authorization_request_url(Scopes, redirect_uri=redirect_uri)

    # webbrowser.open may fail silently
    print("Navigate to the following url in a web browser, if doesn't open automatically:")
    print(url)
    try:
        webbrowser.open(url)
    except Exception:
        pass

    class Handler(http.server.BaseHTTPRequestHandler):
        def do_GET(self):
            parsed_url = urllib.parse.urlparse(self.path)
            parsed_query = urllib.parse.parse_qs(parsed_url.query)
            global code
            code = next(iter(parsed_query['code']), '')

            response_body = b'Success. Look back at your terminal.\r\n'
            self.send_response(200)
            self.send_header('Content-Type', 'text/plain')
            self.send_header('Content-Length', len(response_body))
            self.end_headers()
            self.wfile.write(response_body)

            global httpd
            t = threading.Thread(target=lambda: httpd.shutdown())
            t.start()


    code = ''

    with NamedTemporaryFile(delete=False, suffix=".cert") as cert_file, NamedTemporaryFile(delete=False, suffix=".key") as key_file:
        cert_file.write(SERVER_CERT.encode())
        key_file.write(SERVER_KEY.encode())
        cert_file_path = cert_file.name
        key_file_path = key_file.name

    server_address = ('', random_port)
    httpd = http.server.HTTPServer(server_address, Handler)
    context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
    context.load_cert_chain(cert_file_path, key_file_path)
    httpd.socket = context.wrap_socket(
        httpd.socket,
        server_side=True,
    )

    # If we are running over ssh then the browser on the local machine
    # would never be able access localhost:random_port
    if not os.getenv('SSH_CONNECTION'):
        httpd.serve_forever()

    if code == '':
        print('After login, you will be redirected to a blank (or error) page with a url containing an access code. Paste the url below.')
        resp = input('Response url: ')

        i = resp.find('code') + 5
        code = resp[i : resp.find('&', i)] if i > 4 else resp

    token = app.acquire_token_by_authorization_code(code, Scopes, redirect_uri=redirect_uri)

elif choice == "2" or "--device" in sys.argv:
    # Use PublicClientApplication for device code flow
    app = PublicClientApplication(ClientId, token_cache=cache)

    # Device code flow
    device_flow = app.initiate_device_flow(scopes=Scopes)
    if "error" in device_flow:
        sys.exit(f"Failed to initiate device flow: {device_flow['error_description']}")

    print(f"To authenticate, visit {device_flow['verification_uri']} and enter the code: {device_flow['user_code']}")
    token = app.acquire_token_by_device_flow(device_flow)

else:
    sys.exit("Invalid choice. Please restart the script and choose either 1 or 2.")

if "error" in token:
    print(token)
    sys.exit("Failed to get access token")

print('Saved refresh token to keyring')
save_refresh_token(token['refresh_token'])
